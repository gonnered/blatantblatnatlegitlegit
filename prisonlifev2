 local library = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/vuInerability/thugsense/refs/heads/main/library.lua'
    )
)()
local flags = library.flags

-- FIX: ADD MISSING FOLDERS SETUP
if not isfolder("thugsense") then
    makefolder("thugsense")
end
if not isfolder("thugsense/Configs") then
    makefolder("thugsense/Configs")
end

local Window = library:Window({
    Name = 'barbians',
    FadeSpeed = 0.25,
})

local Watermark = library:Watermark(
    'thugsense ~ '
        .. os.date('%b %d %Y')
        .. ' ~ '
        .. game:GetService('MarketplaceService')
            :GetProductInfo(game.PlaceId).Name
)
local KeybindList = library:KeybindList()

Watermark:SetVisibility(false)
KeybindList:SetVisibility(false)

local CombatTab = Window:Page({ Name = 'Combat', Columns = 2, Subtabs = false })
local MiscTab = Window:Page({ Name = 'Misc', Columns = 2, Subtabs = false })
local VisualsTab = Window:Page({ Name = 'Visuals', Columns = 2, Subtabs = false })
local SettingsTab = Window:Page({ Name = 'Settings', Columns = 2, Subtabs = false })

-- COMBINED TARGET AIM + ADONIS BYPASS - FIXED SYNTAX ERROR
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Camera = Workspace.CurrentCamera

-- ADONIS BYPASS INJECTION - LOAD FIRST
local function InjectAdonisBypass()
    local DEBUG_MODE = false
    local SEND_NOTIFICATIONS = true
    local HookedFunctions = {}
    local DetectedFunc, KillFunc

    local function dbgWarn(msg)
        if DEBUG_MODE then warn(msg) end
    end

    local function notify(title, text, dur)
        if SEND_NOTIFICATIONS then
            pcall(function()
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = title,
                    Text = text,
                    Duration = dur or 3
                })
            end)
        end
    end

    -- Thread identity manipulation
    pcall(function() setthreadidentity(2) end)

    -- Scan and hook Adonis functions
    for _, obj in ipairs(getgc(true)) do
        if typeof(obj) == "table" then
            local detect = rawget(obj, "Detected")
            local kill = rawget(obj, "Kill")

            -- Hook Detected function
            if typeof(detect) == "function" and not DetectedFunc then
                DetectedFunc = detect
                local old; old = hookfunction(detect, function(action, info, noCrash)
                    if action ~= "_" then
                        dbgWarn("Adonis flag blocked | Method: " .. tostring(action) .. " | Info: " .. tostring(info))
                    end
                    return true
                end)
                table.insert(HookedFunctions, DetectedFunc)
            end

            -- Hook Kill function
            if rawget(obj, "Variables") and rawget(obj, "Process") and typeof(kill) == "function" and not KillFunc then
                KillFunc = kill
                local old; old = hookfunction(kill, function(info)
                    dbgWarn("Adonis kill attempt blocked | Info: " .. tostring(info))
                end)
                table.insert(HookedFunctions, KillFunc)
            end

            -- Table mutation bypass
            local indexInstance = rawget(obj, "indexInstance")
            if typeof(indexInstance) == "table" and indexInstance[1] == "kick" then
                setreadonly(obj, false)
                setreadonly(indexInstance, false)
                rawset(obj, "Table", {"kick", function() coroutine.yield() end})
                dbgWarn("Mutated indexInstance to block kick communication")
            end
        end
    end

    -- Hook debug.info sanity check
    local old; old = hookfunction(getrenv().debug.info, newcclosure(function(...)
        local a, b = ...
        if DetectedFunc and a == DetectedFunc then
            dbgWarn("Blocked Adonis debug.info sanity check")
            return coroutine.yield(coroutine.running())
        end
        return old(...)
    end))

    -- Anti-Kick (__namecall hook)
    local old; old = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        if typeof(method) == "string" and method:lower() == "kick" then
            notify("Anti-Kick", "Kick attempt blocked", 3)
            return nil
        end
        return old(self, ...)
    end)

    -- Memory protection
    local function ObfuscateStrings()
        local important_strings = {
            "SilentAim", "TargetAim", "GetClosest", "Raycast", 
            "HitChance", "Fov", "Tracer", "Chams", "Adonis", "Bypass"
        }
        
        for _, str in pairs(important_strings) do
            local new_str = string.reverse(str) .. math.random(1000, 9999)
            _G[new_str] = str
        end
    end

    ObfuscateStrings()

    pcall(function() setthreadidentity(7) end)
    notify("Adonis Bypass", "Protection loaded successfully", 4)
    dbgWarn("Hooked " .. tostring(#HookedFunctions) .. " Adonis functions")
end

-- Execute bypass before anything else
pcall(InjectAdonisBypass)

-- TARGET AIM CONFIGURATION
local HitSoundId = {
    Bameware = "rbxassetid://3124331820",
    Bell = "rbxassetid://6534947240",
    Bubble = "rbxassetid://6534947588",
    Pick = "rbxassetid://1347140027",
    Pop = "rbxassetid://198598793",
    Rust = "rbxassetid://1255040462",
    Sans = "rbxassetid://3188795283",
    Fart = "rbxassetid://130833677",
    Big = "rbxassetid://5332005053",
    Vine = "rbxassetid://5332680810",
    Bruh = "rbxassetid://4578740568",
    Skeet = "rbxassetid://5633695679",
    Neverlose = "rbxassetid://6534948092",
    Fatality = "rbxassetid://6534947869",
    Bonk = "rbxassetid://5766898159",
    Minecraft = "rbxassetid://4018616850"
}

local Config = {
    enabled = false,
    fov = 50,
    followMouse = false,
    targetPart = "Head",
    showFov = false,
    showTracer = false,
    showChams = false,
    faceTarget = false,
    visibleCheck = true,
    hitChance = 100,
    randomHitParts = {"Head", "Torso"},
    targetGuards = true,
    targetCriminals = true,
    targetNeutrals = true,
    targetInmates = true,
    fovColor = Color3.fromRGB(255, 255, 255),
    tracerColor = Color3.fromRGB(255, 255, 255),
    chamsColor = Color3.fromRGB(255, 255, 255),
    fovMethod = "center stuck",
    hitSound = false,
    hitSoundType = "Skeet",
    fogEnabled = false,
    fogStart = 150,
    fogEnd = 500,
    fogDensity = 0.35,
    fogColorR = 140,
    fogColorG = 180,
    fogColorB = 255
}

-- UI SETUP WITH PROTECTION
local core_gui = game:GetService('CoreGui')
local uis = game:GetService('UserInputService')
local gui = game:GetService('GuiService')

local _index = Instance.new('ScreenGui', core_gui)
_index.Name = "FovGui_" .. tostring(math.random(10000,99999))

local FovFrame
local FovGradient
local FovOutline
local FovOutlineGradient

local rotating_gradients = {}
local function add_rotating_gradient(gradient, rotation_settings)
    table.insert(rotating_gradients, {gradient = gradient, settings = rotation_settings})
end

local function create_fov_circle()
    FovFrame = Instance.new("Frame", _index)
    FovFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    FovFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    FovFrame.Size = UDim2.new(0, Config.fov * 2, 0, Config.fov * 2)
    FovFrame.BackgroundColor3 = Config.fovColor
    FovFrame.BackgroundTransparency = 0.45
    FovFrame.Visible = false
    
    local corner = Instance.new("UICorner", FovFrame)
    corner.CornerRadius = UDim.new(0.5, 0)
    
    FovOutline = Instance.new("UIStroke", FovFrame)
    FovOutline.Color = Color3.fromRGB(0, 0, 0)
    FovOutline.Transparency = 0
    FovOutline.Thickness = 1
    
    FovGradient = Instance.new("UIGradient", FovFrame)
    FovGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(211, 211, 211)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 100))
    }
    FovGradient.Rotation = 90
    FovGradient.Offset = Vector2.new(0, 0)
    add_rotating_gradient(FovGradient, {Auto = true, Speed = 120})
    
    FovOutlineGradient = Instance.new("UIGradient", FovOutline)
    FovOutlineGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(211, 211, 211)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 80, 80))
    }
    FovOutlineGradient.Rotation = 90
    add_rotating_gradient(FovOutlineGradient, {Auto = true, Speed = 120})
end

create_fov_circle()

local Tracer = Drawing.new("Line")
Tracer.Color = Config.tracerColor
Tracer.Thickness = 1
Tracer.Transparency = 0.9
Tracer.Visible = false

local ChamsFolder = Instance.new("Folder", game.CoreGui)
ChamsFolder.Name = "ChamsHighlights_" .. tostring(math.random(10000,99999))
local CurrentHighlightTarget = nil

local SilentTarget = nil
local TrackedHealthValues = {}

local HitSound = Instance.new("Sound")
HitSound.Parent = game:GetService("SoundService")
HitSound.Volume = 0.5

local FogSky = nil
local FogAtmos = nil
local FogCC = nil

-- PROTECTED FUNCTIONS
local function ApplyFog()
    if not Config.fogEnabled then
        if FogSky then FogSky:Destroy() FogSky = nil end
        if FogAtmos then FogAtmos:Destroy() FogAtmos = nil end
        if FogCC then FogCC:Destroy() FogCC = nil end
        return
    end
    
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("Sky") and v ~= FogSky then
            v:Destroy()
        end
    end
    
    if not FogSky then
        FogSky = Instance.new("Sky")
        FogSky.SkyboxBk = ""
        FogSky.SkyboxDn = ""
        FogSky.SkyboxFt = ""
        FogSky.SkyboxLf = ""
        FogSky.SkyboxRt = ""
        FogSky.SkyboxUp = ""
        FogSky.Parent = Lighting
    end
    
    local fogColor = Color3.fromRGB(Config.fogColorR, Config.fogColorG, Config.fogColorB)
    
    Lighting.FogColor = fogColor
    Lighting.FogStart = Config.fogStart
    Lighting.FogEnd = Config.fogEnd
    
    if not FogAtmos then
        FogAtmos = Instance.new("Atmosphere")
        FogAtmos.Parent = Lighting
    end
    
    FogAtmos.Color = Color3.fromRGB(
        math.clamp(Config.fogColorR + 20, 0, 255),
        math.clamp(Config.fogColorG + 20, 0, 255),
        math.clamp(Config.fogColorB, 0, 255)
    )
    FogAtmos.Decay = Color3.fromRGB(
        math.clamp(Config.fogColorR - 90, 0, 255),
        math.clamp(Config.fogColorG - 100, 0, 255),
        math.clamp(Config.fogColorB - 105, 0, 255)
    )
    FogAtmos.Density = Config.fogDensity
    FogAtmos.Offset = 0.3
    FogAtmos.Haze = 1.5
    FogAtmos.Glare = 0
    
    if not FogCC then
        FogCC = Instance.new("ColorCorrectionEffect")
        FogCC.Parent = Lighting
    end
    
    FogCC.TintColor = Color3.fromRGB(
        math.clamp(Config.fogColorR + 30, 0, 255),
        math.clamp(Config.fogColorG + 20, 0, 255),
        math.clamp(Config.fogColorB, 0, 255)
    )
    FogCC.Brightness = 0.05
    FogCC.Contrast = 0.05
end

local function CreateChams(character)
    if not Config.showChams then
        ChamsFolder:ClearAllChildren()
        return
    end
    
    ChamsFolder:ClearAllChildren()
    
    local highlight = Instance.new("Highlight")
    highlight.Parent = ChamsFolder
    highlight.Adornee = character
    highlight.FillColor = Config.chamsColor
    highlight.OutlineColor = Config.chamsColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
end

-- ENHANCED TEAM CHECK FUNCTION
local function GetTeamFromCharacter(character)
    local player = Players:GetPlayerFromCharacter(character)
    if not player then return nil end
    
    local teamFolder = character:FindFirstChild("Team")
    if teamFolder and teamFolder:IsA("StringValue") then
        return teamFolder.Value
    end
    
    if player.Team then
        return player.Team.Name
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        local displayName = humanoid.DisplayName
        if displayName:lower():find("guard") or displayName:lower():find("police") then
            return "Guard"
        elseif displayName:lower():find("criminal") or displayName:lower():find("prisoner") then
            return "Criminal"
        elseif displayName:lower():find("inmate") then
            return "Inmate"
        end
    end
    
    return nil
end

-- ENHANCED WALL CHECK FUNCTION
local function IsVisible(part, ignoreList)
    if not part then return false end
    
    local character = part.Parent
    if not character then return false end
    
    local cameraPos = Camera.CFrame.Position
    local partPos = part.Position
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = ignoreList or {LocalPlayer.Character, Camera}
    
    local raycastResult = Workspace:Raycast(cameraPos, (partPos - cameraPos).Unit * 1000, raycastParams)
    
    if raycastResult then
        local hitPart = raycastResult.Instance
        if hitPart and (hitPart:IsDescendantOf(character) or hitPart.Name == "HumanoidRootPart" or hitPart.Name == "Head" or hitPart.Name == "Torso") then
            return true
        else
            return false
        end
    end
    
    return true
end

-- ENHANCED TARGET CHECK FUNCTION
local function ShouldTargetPlayer(character)
    if not character then return false end
    
    local team = GetTeamFromCharacter(character)
    if not team then 
        return Config.targetNeutrals
    end
    
    if team == "Guard" or team == "Police" or team == "Security" or team:lower():find("guard") or team:lower():find("police") then
        return Config.targetGuards
    elseif team == "Criminal" or team == "Prisoner" or team:lower():find("criminal") or team:lower():find("prisoner") then
        return Config.targetCriminals
    elseif team == "Neutral" or team == "Civilian" or team:lower():find("neutral") or team:lower():find("civilian") then
        return Config.targetNeutrals
    elseif team == "Inmate" or team:lower():find("inmate") then
        return Config.targetInmates
    end
    
    return true
end

local function PlayHitSound()
    if Config.hitSound and HitSoundId[Config.hitSoundType] then
        HitSound.SoundId = HitSoundId[Config.hitSoundType]
        HitSound:Play()
    end
end

local function MonitorTargetHealth(character)
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    local player = Players:GetPlayerFromCharacter(character)
    if not player then return end
    
    local currentHealth = humanoid.Health
    local lastHealth = TrackedHealthValues[player.UserId] or currentHealth
    
    if currentHealth < lastHealth and (Config.showChams or Config.showTracer) then
        PlayHitSound()
    end
    
    TrackedHealthValues[player.UserId] = currentHealth
end

-- ENHANCED GET CLOSEST WITH WALL CHECK & TEAM CHECK
local function GetClosest()
    if not Config.enabled then return nil end

    local center
    if Config.fovMethod == "center move" then
        center = UserInputService:GetMouseLocation()
    else
        center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    end
    
    local bestPart = nil
    local bestDist = Config.fov

    for _, plr in Players:GetPlayers() do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
            if not ShouldTargetPlayer(plr.Character) then 
                continue
            end
            
            local part = plr.Character:FindFirstChild(Config.targetPart) or plr.Character:FindFirstChild("Head")
            if part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(pos.X, pos.Y) - center).Magnitude
                    if dist < bestDist then
                        if not Config.visibleCheck then
                            bestDist = dist
                            bestPart = part
                        else
                            local ignoreList = {LocalPlayer.Character, Camera}
                            if IsVisible(part, ignoreList) then
                                bestDist = dist
                                bestPart = part
                            end
                        end
                    end
                end
            end
        end
    end
    return bestPart
end

-- PROTECTED METAMETHOD HOOK
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if not checkcaller() and method == "Raycast" and self == Workspace and Config.enabled and SilentTarget then
        local hitSuccess = math.random(1, 100) <= Config.hitChance
        
        if hitSuccess then
            args[1] = Camera.CFrame.Position
            args[2] = (SilentTarget.Position - Camera.CFrame.Position).Unit * 1000
        else
            local randomPart = Config.randomHitParts[math.random(1, #Config.randomHitParts)]
            local character = SilentTarget.Parent
            local missPart = character:FindFirstChild(randomPart) or SilentTarget
            args[1] = Camera.CFrame.Position
            args[2] = (missPart.Position - Camera.CFrame.Position).Unit * 1000
        end

        if args[3] and typeof(args[3]) == "RaycastParams" then
            args[3] = args[3]
        end

        return oldNamecall(self, unpack(args))
    end

    return oldNamecall(self, ...)
end)

setreadonly(mt, true)

-- MAIN LOOP WITH PROTECTION
local lastUpdate = 0
local updateInterval = 0.033

local function update_fov_position(mode)
    if mode == "center move" then
        local gui_inset = gui:GetGuiInset()
        local mouse_pos = uis:GetMouseLocation()
        FovFrame.Position = UDim2.new(0, mouse_pos.X - gui_inset.X, 0, mouse_pos.Y - gui_inset.Y)
    else
        FovFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    end
end

RunService.RenderStepped:Connect(function()
    local now = tick()
    
    for _, data in pairs(rotating_gradients) do
        local gradient = data.gradient
        if gradient and data.settings.Auto then
            gradient.Rotation = (tick() * (data.settings.Speed or 120)) % 360
        end
    end
    
    update_fov_position(Config.fovMethod)
    
    FovFrame.Size = UDim2.new(0, Config.fov * 2, 0, Config.fov * 2)
    FovFrame.Visible = Config.showFov
    FovFrame.BackgroundColor3 = Config.fovColor

    if now - lastUpdate >= updateInterval then
        lastUpdate = now
        SilentTarget = GetClosest()
    end

    if SilentTarget and SilentTarget.Parent then
        local pos, onScreen = Camera:WorldToViewportPoint(SilentTarget.Position)
        if onScreen then
            local center
            if Config.fovMethod == "center move" then
                center = UserInputService:GetMouseLocation()
            else
                center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            end
            
            Tracer.From = center
            Tracer.To = Vector2.new(pos.X, pos.Y)
            Tracer.Visible = Config.showTracer
            Tracer.Color = Config.tracerColor
            
            local targetChar = SilentTarget.Parent
            if CurrentHighlightTarget ~= targetChar then
                CurrentHighlightTarget = targetChar
                CreateChams(targetChar)
            end
            
            MonitorTargetHealth(targetChar)
            
            if Config.faceTarget and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = LocalPlayer.Character.HumanoidRootPart
                local targetPos = SilentTarget.Position
                local lookAt = CFrame.new(hrp.Position, Vector3.new(targetPos.X, hrp.Position.Y, targetPos.Z))
                hrp.CFrame = lookAt
            end
        else
            Tracer.Visible = false
            ChamsFolder:ClearAllChildren()
            CurrentHighlightTarget = nil
        end
    else
        Tracer.Visible = false
        ChamsFolder:ClearAllChildren()
        CurrentHighlightTarget = nil
    end
end)

-- UI SETUP WITH WALL CHECK TOGGLE
if CombatTab then
    local TargetAimSection = CombatTab:Section({ Name = 'Target Aim', Side = 1 })

    TargetAimSection:Toggle({
        name = "Enabled",
        default = false,
        flag = "TargetAimToggle",
        callback = function(v) 
            Config.enabled = v
            if v then
                pcall(function() setfpscap(999) end)
            end
        end
    }):Keybind({
        name = "Lock Keybind",
        mode = "Toggle",
        default = Enum.KeyCode.Q,
        flag = "LockKeybind"
    })
    
    TargetAimSection:Slider({
        Name = 'Hit Chance',
        Min = 0,
        Max = 100,
        Default = 100,
        Suffix = '%',
        Decimals = 1,
        Compact = true,
        Flag = 'Hit Chance',
        Callback = function(Value)
            if type(Value) == "number" then
                Config.hitChance = Value
            end
        end
    })

    TargetAimSection:Toggle({
        Name = 'Wall Check',
        Flag = 'WallCheck',
        Default = true,
        Callback = function(Value)
            Config.visibleCheck = Value
        end
    })

    TargetAimSection:Toggle({
        Name = 'FoV',
        Flag = 'FoV',
        Default = false,
        Callback = function(Value)
            Config.showFov = Value
        end
    }):Colorpicker({
        Name = 'FoV Color',
        Flag = 'FoV Color',
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Value, Alpha)
            Config.fovColor = Value
        end
    })
    
    TargetAimSection:Divider()

    TargetAimSection:Toggle({
        Name = 'charms',
        Flag = 'charms',
        Default = false,
        Callback = function(Value)
            Config.showChams = Value
            if not Value then
                ChamsFolder:ClearAllChildren()
            end
        end
    }):Colorpicker({
        Name = 'highlight Color',
        Flag = 'highlight Color',
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Value, Alpha)
            Config.chamsColor = Value
        end
    })

    TargetAimSection:Toggle({
        name = "face target",
        default = false,
        flag = "EnableFeature",
        callback = function(value)
            Config.faceTarget = value
        end
    })

    TargetAimSection:Toggle({
        Name = 'tracer',
        Flag = 'tracer',
        Default = false,
        Callback = function(Value)
            Config.showTracer = Value
        end
    }):Colorpicker({
        Name = 'tracer Color',
        Flag = 'tracer Color',
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Value, Alpha)
            Config.tracerColor = Value
        end
    })

    TargetAimSection:Slider({
        Name = 'FoV Size',
        Min = 0,
        Max = 1000,
        Default = 50,
        Decimals = 0.1,
        Flag = 'FoV Size',
        Callback = function(Value)
            if type(Value) == "number" then
                Config.fov = Value
            end
        end
    })

    TargetAimSection:Dropdown({
        Name = 'Bone',
        Flag = 'Bone',
        Default = 'Head',
        Items = { 'Head', 'Torso', 'Cock', 'AssðŸ¤¤' },
        Callback = function(Value)
            Config.targetPart = Value
        end
    })

    TargetAimSection:Dropdown({
        name = "Fov",
        items = {"center stuck", "center move", "Hard"},
        default = "center stuck",
        flag = "fov method",
        multi = false,
        callback = function(option)
            Config.fovMethod = option
        end
    })

    TargetAimSection:Dropdown({
        Name = 'Multi part',
        Flag = 'Multi Bone',
        Default = { 'Head', 'Torso' },
        Multi = true,
        Items = { 'Head', 'Torso', 'Cock', 'AssðŸ¤¤' },
        Callback = function(Value)
            Config.randomHitParts = Value
        end
    })
    
    local Ragebot, Originscan, Visuals = CombatTab:MultiSection({
        Sections = { 'Whitelist' },
        Side = 2,
    })

    Ragebot:Toggle({
        Name = 'no guard',
        Flag = 'no guard',
        Default = false,
        Callback = function(Value)
            Config.targetGuards = not Value
        end
    })

    Ragebot:Toggle({
        Name = 'no criminal',
        Flag = 'nocriminal',
        Default = false,
        Callback = function(Value)
            Config.targetCriminals = not Value
        end
    })

    Ragebot:Toggle({
        Name = 'no neutral',
        Flag = 'no neutral',
        Default = false,
        Callback = function(Value)
            Config.targetNeutrals = not Value
        end
    })

    Ragebot:Toggle({
        Name = 'no inmates',
        Flag = 'no inmates',
        Default = false,
        Callback = function(Value)
            Config.targetInmates = not Value
        end
    })
end

if VisualsTab then
    local PlayerVisualsSection = VisualsTab:Section({ Name = 'Player Visuals', Side = 2 })

    PlayerVisualsSection:Toggle({
        Name = 'hit sound',
        Flag = 'HitEffectToggle',
        Default = false,
        Callback = function(Value)
            Config.hitSound = Value
        end
    })

    PlayerVisualsSection:Dropdown({
        Name = 'hit sound',
        Flag = 'HitEffectStyle',
        Default = 'Skeet',
        Items = {"Bameware", "Bell", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Neverlose", "Fatality", "Bonk", "Minecraft"},
        Callback = function(Value)
            Config.hitSoundType = Value
        end
    })
end

-- CLEANUP PROTECTION
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        pcall(function()
            if _index then _index:Destroy() end
            if ChamsFolder then ChamsFolder:Destroy() end
            if Tracer then Tracer:Remove() end
        end)
    end
end)

warn("TARGET AIM + ADONIS BYPASS FULLY LOADED - WALL CHECK & TEAM CHECK ACTIVE")

do
    local PlayerVisualsSection = VisualsTab:Section({ Name = 'Player Visuals', Side = 2 })

    PlayerVisualsSection:Toggle({
        Name = 'hit sound',
        Flag = 'HitEffectToggle',
        Default = false,
        Callback = function(Value)
            Config.hitSound = Value
        end
    })

    PlayerVisualsSection:Dropdown({
        Name = 'hit sound',
        Flag = 'HitEffectStyle',
        Default = 'Skeet',
        Items = {"Bameware", "Bell", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Neverlose", "Fatality", "Bonk", "Minecraft"},
        Callback = function(Value)
            Config.hitSoundType = Value
        end
    })
end

print("SILENT AIM LOADED - FOV POSITION FIXED + WALL/TEAM CHECK ADDED")

do
    local CharacterSection = MiscTab:Section({ Name = 'Character', Side = 2 })

    CharacterSection:Toggle({
        Name = "orbit",
        Flag = "OrbitToggle",
        Default = false,
        Callback = function(v) 
            print("Orbit:", v)
        end
    }):Keybind({
        Name = "Toggle Key",
        Mode = "Toggle",
        Default = Enum.KeyCode.Q,
        Flag = "OrbitKeybind",
        Callback = function(active)
            print("Orbit Keybind active:", active)
        end
    })

    CharacterSection:Slider({
        Name = "speed",
        Min = 0,
        Max = 100,
        Decimals = 1,
        Default = 50,
        Suffix = "%",
        Flag = "OrbitSpeed",
        Callback = function(value)
            if type(value) == "number" then
                print("Speed:", value)
            end
        end
    })

    CharacterSection:Slider({
        Name = "height",
        Min = 0,
        Max = 100,
        Decimals = 1,
        Default = 50,
        Suffix = "%",
        Flag = "OrbitHeight",
        Callback = function(value)
            if type(value) == "number" then
                print("Height:", value)
            end
        end
    })

    CharacterSection:Slider({
        Name = "radius",
        Min = 0,
        Max = 100,
        Decimals = 1,
        Default = 50,
        Suffix = "%",
        Flag = "OrbitRadius",
        Callback = function(value)
            if type(value) == "number" then
                print("Radius:", value)
            end
        end
    })
    
    CharacterSection:Divider()
    
    local FogSection = MiscTab:Section({ Name = 'Fog', Side = 2 })
    
    FogSection:Toggle({
        Name = "Enable Fog",
        Default = false,
        Flag = "FogEnabled",
        Callback = function(value)
            Config.fogEnabled = value
            ApplyFog()
        end
    })
    
    FogSection:Slider({
        Name = "Fog Start",
        Min = 0,
        Max = 500,
        Decimals = 1,
        Default = 150,
        Flag = "FogStart",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogStart = value
                ApplyFog()
            end
        end
    })
    
    FogSection:Slider({
        Name = "Fog End",
        Min = 100,
        Max = 2000,
        Decimals = 1,
        Default = 500,
        Flag = "FogEnd",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogEnd = value
                ApplyFog()
            end
        end
    })
    
    FogSection:Slider({
        Name = "Fog Density",
        Min = 0,
        Max = 1,
        Decimals = 0.01,
        Default = 0.35,
        Flag = "FogDensity",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogDensity = value
                ApplyFog()
            end
        end
    })
    
    FogSection:Divider()
    
    FogSection:Slider({
        Name = "Red",
        Min = 0,
        Max = 255,
        Decimals = 1,
        Default = 140,
        Flag = "FogColorR",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogColorR = value
                ApplyFog()
            end
        end
    })
    
    FogSection:Slider({
        Name = "Green",
        Min = 0,
        Max = 255,
        Decimals = 1,
        Default = 180,
        Flag = "FogColorG",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogColorG = value
                ApplyFog()
            end
        end
    })
    
    FogSection:Slider({
        Name = "Blue",
        Min = 0,
        Max = 255,
        Decimals = 1,
        Default = 255,
        Flag = "FogColorB",
        Callback = function(value)
            if type(value) == "number" then
                Config.fogColorB = value
                ApplyFog()
            end
        end
    })
end

print("SILENT AIM LOADED - UI INTEGRATED - HIT SOUNDS + FOG ADDED - 2025")

do
    local PlayerVisualsSection = VisualsTab:Section({ Name = 'Player Visuals', Side = 2 })

    PlayerVisualsSection:Toggle({
        Name = 'hit sound',
        Flag = 'HitEffectToggle',
        Default = false,
        Callback = function(Value)
            print(Value)
        end
    })

    PlayerVisualsSection:Dropdown({
        Name = 'hit sound',
        Flag = 'HitEffectStyle',
        Default = 'option 1',
        Items = { 'option 1', 'option 2', 'option 3', 'option 4', 'option 5' },
        Callback = function(Value)
            print(Value)
        end
    })
end

do
    local MovementSection = MiscTab:Section({ Name = 'Movement', Side = 1 })

    MovementSection:Toggle({
        Name = 'cframe speed',
        Flag = 'CFrameSpeedToggle',
        Default = false,
        Callback = function(Value)
            print(Value)
        end
    }):Keybind({
        Name = 'Hotkey',
        Flag = 'CFrameSpeedHotkey',
        Default = Enum.KeyCode.Z,
        Mode = 'Toggle',
        Callback = function(Value)
            print(Value)
        end
    })

    MovementSection:Toggle({
        Name = 'cframe fly',
        Flag = 'CFrameFlyToggle',
        Default = false,
        Callback =  function(Value)
            print(Value)
        end
    }):Keybind({
        Name = 'Hotkey',
        Flag = 'CFrameFlyHotkey',
        Default = Enum.KeyCode.X,
        Mode = 'Toggle',
        Callback = function(Value)
            print(Value)
        end
    })

    MovementSection:Toggle({
        Name = 'noclip',
        Flag = 'NoclipToggle',
        Default = false,
        Callback = function(Value)
            print(Value)
        end
    })

    MovementSection:Divider()

    MovementSection:Slider({
        Name = 'cframe speed value',
        Min = 0,
        Max = 1000,
        Default = 100,
        Decimals = 1,
        Flag = 'CFrameSpeedValue',
        Callback = function(Value)
            if type(Value) == "number" then
                print(Value)
            end
        end
    })

    MovementSection:Slider({
        Name = 'fly speed value',
        Min = 0,
        Max = 1000,
        Default = 100,
        Decimals = 1,
        Flag = 'FlySpeedValue',
        Callback = function(Value)
            if type(Value) == "number" then
                print(Value)
            end
        end
    })
end

do
    local EmoteSection = MiscTab:Section({ Name = 'Emotes', Side = 1 })

    EmoteSection:Toggle({
        Name = 'Enabled',
        Flag = 'EmotesEnabled',
        Default = false,
        Callback = function(Value)
            print(Value)
        end
    })

    EmoteSection:Divider()

    EmoteSection:Dropdown({
        Name = 'Emote Selection',
        Flag = 'EmoteSelection',
        Default = 'Floss',
        Multi = false,
        Items = { 'Floss', 'yungblud happier jump' },
        Callback = function(Value)
            print(Value)
        end
    })
end

local CharmManager = {}
do
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local charmEnabled = false
    local charmColor = Color3.fromRGB(255, 255, 255)
    local originalMaterials = {}
    local originalColors = {}

    local function saveOriginalAppearance(character)
        originalMaterials = {}
        originalColors = {}
        
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                originalMaterials[part] = part.Material
                originalColors[part] = part.Color
            end
        end
        
        for _, acc in pairs(character:GetChildren()) do
            if acc:IsA("Accessory") and acc:FindFirstChild("Handle") then
                originalMaterials[acc.Handle] = acc.Handle.Material
                originalColors[acc.Handle] = acc.Handle.Color
            end
        end
    end

    local function restoreOriginalAppearance(character)
        for part, material in pairs(originalMaterials) do
            if part and part.Parent then
                part.Material = material
            end
        end
        for part, color in pairs(originalColors) do
            if part and part.Parent then
                part.Color = color
            end
        end
    end

    local function applyCharmMaterial(character)
        if not charmEnabled then return end
        
        character:WaitForChild("Humanoid")
        saveOriginalAppearance(character)
        
        local function applyForceFieldMaterial(part)
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.Material = Enum.Material.ForceField
                part.Color = charmColor
            end
        end
        
        for _, part in pairs(character:GetChildren()) do
            applyForceFieldMaterial(part)
        end
        
        for _, acc in pairs(character:GetChildren()) do
            if acc:IsA("Accessory") and acc:FindFirstChild("Handle") then
                applyForceFieldMaterial(acc.Handle)
            end
        end
    end

    local function handleCharacterAdded(char)
        char:WaitForChild("Humanoid")
        if charmEnabled then
            applyCharmMaterial(char)
        end
    end

    if player.Character then
        handleCharacterAdded(player.Character)
    end
    player.CharacterAdded:Connect(handleCharacterAdded)

    CharmManager.SetCharmEnabled = function(enabled)
        charmEnabled = enabled
        local character = player.Character
        if character then
            if enabled then
                applyCharmMaterial(character)
            else
                restoreOriginalAppearance(character)
            end
        end
    end

    CharmManager.SetCharmColor = function(color)
        charmColor = color
        if charmEnabled and player.Character then
            applyCharmMaterial(player.Character)
        end
    end
end

local TrailManager = {}
do
    local default = {
        trail = { 
            enable = false, 
            rgb = Color3.fromRGB(255, 255, 255), 
            thickness = 1 
        }
    }

    local ps = game:GetService("Players")
    local lp = ps.LocalPlayer
    local rs = game:GetService("RunService")

    local function createTrail(character)
        if not default.trail.enable then return end
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
        if not humanoidRootPart then return end
        
        local existingTrail = humanoidRootPart:FindFirstChildOfClass("Trail")
        if existingTrail then
            existingTrail:Destroy()
        end
        
        local attachment0 = Instance.new("Attachment")
        attachment0.Position = Vector3.new(0, 0, 0)
        attachment0.Name = "TrailAttachment0"
        attachment0.Parent = humanoidRootPart
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Position = Vector3.new(0, 0, -0.5)
        attachment1.Name = "TrailAttachment1"
        attachment1.Parent = humanoidRootPart
        
        local trail = Instance.new("Trail")
        trail.Attachment0 = attachment0
        trail.Attachment1 = attachment1
        trail.WidthScale = NumberSequence.new(default.trail.thickness)
        trail.Color = ColorSequence.new(default.trail.rgb)
        trail.Parent = humanoidRootPart
        
        return trail
    end

    local function handleCharacterAdded(character)
        createTrail(character)
    end

    if lp.Character then
        handleCharacterAdded(lp.Character)
    end
    lp.CharacterAdded:Connect(handleCharacterAdded)

    TrailManager.SetTrailEnabled = function(bool)
        default.trail.enable = bool
        if lp.Character then
            local humanoidRootPart = lp.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local existingTrail = humanoidRootPart:FindFirstChildOfClass("Trail")
                if bool and not existingTrail then
                    createTrail(lp.Character)
                elseif not bool and existingTrail then
                    existingTrail:Destroy()
                end
            end
        end
    end

    TrailManager.SetTrailColor = function(color)
        default.trail.rgb = color
        if lp.Character then
            local existingTrail = lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart:FindFirstChildOfClass("Trail")
            if existingTrail then
                existingTrail.Color = ColorSequence.new(color)
            end
        end
    end

    TrailManager.SetTrailThickness = function(thickness)
        if type(thickness) == "number" then
            default.trail.thickness = thickness
            if lp.Character then
                local existingTrail = lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart:FindFirstChildOfClass("Trail")
                if existingTrail then
                    existingTrail.WidthScale = NumberSequence.new(thickness)
                end
            end
        end
    end
end

local SpinManager = {}
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local player = Players.LocalPlayer

    local settings = {
        spinSpeed = 2000,
        maxSpinSpeed = 5000,
        minSpinSpeed = 100,
        spinning = false
    }

    local character, humanoidRootPart
    local spinConnection

    local function updateCharacter()
        character = player.Character
        if character then
            humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        end
    end

    local function startSpinning()
        if spinConnection then
            spinConnection:Disconnect()
        end
        
        spinConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if settings.spinning and humanoidRootPart and humanoidRootPart.Parent then
                humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(settings.spinSpeed * deltaTime), 0)
            end
        end)
    end

    local function stopSpinning()
        if spinConnection then
            spinConnection:Disconnect()
            spinConnection = nil
        end
    end

    player.CharacterAdded:Connect(function()
        updateCharacter()
        if settings.spinning then
            startSpinning()
        end
    end)

    updateCharacter()

    SpinManager.SetSpinning = function(enabled)
        settings.spinning = enabled
        if enabled then
            startSpinning()
        else
            stopSpinning()
        end
    end

    SpinManager.SetSpinSpeed = function(speed)
        -- FIX: Ensure speed is a number before clamping
        if type(speed) == "number" then
            settings.spinSpeed = math.clamp(speed, settings.minSpinSpeed, settings.maxSpinSpeed)
        else
            warn("SpinManager.SetSpinSpeed: Expected number, got " .. type(speed))
        end
    end
end

do
    local SelfSection = MiscTab:Section({ Name = 'Self', Side = 2 })

    SelfSection:Toggle({
        Name = "self spin",
        Flag = "SelfSpinToggle",
        Default = false,
        Callback = function(value)
            print("Self Spin:", value)
            SpinManager.SetSpinning(value)
        end
    })

    SelfSection:Slider({
        Name = "spin speed",
        Min = 100,
        Max = 5000,
        Decimals = 0,
        Default = 2000,
        Suffix = "",
        Flag = "SelfSpinSpeed",
        Callback = function(value)
            if type(value) == "number" then
                print("Spin Speed:", value)
                SpinManager.SetSpinSpeed(value)
            end
        end
    })

    SelfSection:Toggle({
        Name = "self trail",
        Flag = "SelfTrailToggle",
        Default = false,
        Callback = function(value)
            print("Self Trail:", value)
            TrailManager.SetTrailEnabled(value)
        end
    })

    SelfSection:Slider({
        Name = "trail thickness",
        Min = 0.1,
        Max = 5,
        Decimals = 0.1,
        Default = 1,
        Suffix = "",
        Flag = "TrailThickness",
        Callback = function(value)
            if type(value) == "number" then
                print("Trail Thickness:", value)
                TrailManager.SetTrailThickness(value)
            end
        end
    })

    local charmToggle = SelfSection:Toggle({
        Name = "self charm",
        Flag = "SelfCharmToggle",
        Default = false,
        Callback = function(v) 
            print("Self Charm:", v)
            CharmManager.SetCharmEnabled(v)
        end
    }):Colorpicker({
        Name = "Charm Color",
        Flag = "CharmColor",
        Default = Color3.fromRGB(255, 255, 255),
        Alpha = true,
        Callback = function(color, alpha)
            print("Charm Color:", color, "Alpha:", alpha)
            CharmManager.SetCharmColor(color)
        end
    })
end

do
    local MobileSection = MiscTab:Section({ Name = 'Misc', Side = 2 })

    MobileSection:Button({
        Name = "Load Button",
        Callback = function()
            print("Button clicked!")
        end
    })
end

do
    local ConfigsSection = SettingsTab:Section({ Name = 'Profiles', Side = 1 })
    local SettingsSection = SettingsTab:Section({ Name = 'Settings', Side = 2 })

    -- FIX: ADD MISSING FOLDER PATH
    library.Folders = {
        Configs = "thugsense/Configs"
    }

    -- FIX: ADD MISSING LIBRARY METHODS
    library.RefreshConfigsList = function(listbox)
        local configs = {}
        if isfolder(library.Folders.Configs) then
            for _, file in pairs(listfiles(library.Folders.Configs)) do
                if file:sub(-5) == ".json" then
                    table.insert(configs, file:match("([^/]+)%.json$"))
                end
            end
        end
        listbox:Refresh(configs)
    end

    library.GetConfig = function()
        return game:GetService("HttpService"):JSONEncode(flags)
    end

    library.LoadConfig = function(configData)
        local config = game:GetService("HttpService"):JSONDecode(configData)
        for flag, value in pairs(config) do
            if flags[flag] ~= nil then
                flags[flag] = value
            end
        end
    end

    library.SaveConfig = function(configName)
        writefile(library.Folders.Configs .. '/' .. configName .. '.json', library:GetConfig())
    end

    library.DeleteConfig = function(configName)
        delfile(library.Folders.Configs .. '/' .. configName .. '.json')
    end

    library.ChangeTheme = function(index, color)
        -- Theme change implementation
    end

    library.Notification = function(message, duration, color)
        -- Simple notification
        warn("[thugsense] " .. message)
    end

    local ConfigName
    local ConfigSelected

    local ConfigsListbox = ConfigsSection:Listbox({
        Items = {},
        Name = 'Configs',
        Flag = 'ConfigsList',
        Callback = function(Value)
            ConfigSelected = Value
        end
    })

    ConfigsSection:Textbox({
        Name = 'Config Name',
        Placeholder = 'Enter config name',
        Flag = 'ConfigName',
        Callback = function(Value)
            ConfigName = Value
        end
    })

    ConfigsSection:Button({
        Name = 'Create Config',
        Callback = function()
            if ConfigName and ConfigName ~= '' then
                if not isfile(library.Folders.Configs .. '/' .. ConfigName .. '.json') then
                    writefile(library.Folders.Configs .. '/' .. ConfigName .. '.json', library:GetConfig())
                    library:RefreshConfigsList(ConfigsListbox)
                    library:Notification("Config '" .. ConfigName .. "' created", 3, Color3.fromRGB(0, 255, 0))
                else
                    library:Notification("Config '" .. ConfigName .. "' already exists", 3, Color3.fromRGB(255, 0, 0))
                end
            else
                library:Notification("Please enter a config name", 3, Color3.fromRGB(255, 0, 0))
            end
        end
    })

    ConfigsSection:Button({
        Name = 'Load Config',
        Callback = function()
            if ConfigSelected then
                if isfile(library.Folders.Configs .. '/' .. ConfigSelected .. '.json') then
                    library:LoadConfig(readfile(library.Folders.Configs .. '/' .. ConfigSelected .. '.json'))
                    library:Notification("Config '" .. ConfigSelected .. "' loaded", 3, Color3.fromRGB(0, 255, 0))
                else
                    library:Notification("Config file not found", 3, Color3.fromRGB(255, 0, 0))
                end
            else
                library:Notification("Please select a config", 3, Color3.fromRGB(255, 0, 0))
            end
        end
    })

    ConfigsSection:Button({
        Name = 'Save Config',
        Callback = function()
            if ConfigSelected then
                library:SaveConfig(ConfigSelected)
                library:Notification("Config '" .. ConfigSelected .. "' saved", 3, Color3.fromRGB(0, 255, 0))
            else
                library:Notification("Please select a config", 3, Color3.fromRGB(255, 0, 0))
            end
        end
    })

    ConfigsSection:Button({
        Name = 'Delete Config',
        Callback = function()
            if ConfigSelected then
                library:DeleteConfig(ConfigSelected)
                library:RefreshConfigsList(ConfigsListbox)
                library:Notification("Config '" .. ConfigSelected .. "' deleted", 3, Color3.fromRGB(0, 255, 0))
            else
                library:Notification("Please select a config", 3, Color3.fromRGB(255, 0, 0))
            end
        end
    })

    ConfigsSection:Button({
        Name = 'Refresh Configs',
        Callback = function()
            library:RefreshConfigsList(ConfigsListbox)
            library:Notification("Configs list refreshed", 3, Color3.fromRGB(0, 255, 0))
        end
    })

    -- FIX: ADD THEME SETTINGS
    library.Theme = {
        Accent = Color3.fromRGB(255, 255, 255),
        Background = Color3.fromRGB(20, 20, 20),
        Outline = Color3.fromRGB(50, 50, 50)
    }

    for Index, Value in pairs(library.Theme) do
        SettingsSection:Label({ Name = Index, Alignment = 'Left' })
            :Colorpicker({
                Name = Index,
                Default = Value,
                Flag = 'Theme' .. Index,
                Callback = function(Color)
                    library.Theme[Index] = Color
                    library:ChangeTheme(Index, Color)
                end
            })
    end

    SettingsSection:Label({ Name = 'Menu Keybind', Alignment = 'Left' })
        :Keybind({
            Name = 'Menu Keybind',
            Flag = 'MenuKeybind',
            Default = Enum.KeyCode.RightControl,
            Mode = 'Toggle',
            Callback = function(Value)
                library.MenuKeybind = library.Flags['MenuKeybind'].Key
            end
        })

    SettingsSection:Toggle({
        Name = 'Watermark',
        Flag = 'WatermarkToggle',
        Default = false,
        Callback = function(Value)
            Watermark:SetVisibility(Value)
        end
    })

    SettingsSection:Toggle({
        Name = 'Keybind List',
        Flag = 'KeybindListToggle',
        Default = false,
        Callback = function(Value)
            KeybindList:SetVisibility(Value)
        end
    })

    SettingsSection:Dropdown({
        Name = 'Tweening Style',
        Flag = 'TweeningStyle',
        Default = 'Exponential',
        Items = {
            'Linear', 'Sine', 'Quad', 'Cubic', 'Quart', 'Quint',
            'Exponential', 'Circular', 'Back', 'Elastic', 'Bounce'
        },
        Callback = function(Value)
            library.Tween.Style = Enum.EasingStyle[Value]
        end
    })

    SettingsSection:Dropdown({
        Name = 'Tweening Direction',
        Flag = 'TweeningDirection',
        Default = 'Out',
        Items = { 'In', 'Out', 'InOut' },
        Callback = function(Value)
            library.Tween.Direction = Enum.EasingDirection[Value]
        end
    })

    SettingsSection:Slider({
        Name = 'Tweening Time',
        Min = 0,
        Max = 5,
        Default = 0.25,
        Decimals = 0.01,
        Flag = 'TweeningTime',
        Callback = function(Value)
            if type(Value) == "number" then
                library.Tween.Time = Value
            end
        end
    })

    SettingsSection:Button({
        Name = 'Notification test',
        Callback = function()
            library:Notification(
                'This is a notification test',
                5,
                Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
            )
        end
    })

    SettingsSection:Button({
        Name = 'Unload library',
        Callback = function()
            library:Unload()
        end
    })

    -- INITIALIZE CONFIGS
    library:RefreshConfigsList(ConfigsListbox)
end

getgenv().library = library
return library
